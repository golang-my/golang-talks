Optimization Tips and Tricks
26 November 2019
Tags: go, golang

Chee Leong
Tuxuri

* Not going to cover

- debugger
- profiler

We'll use this

   go test -bench=. -benchmem

* We worry too much about the GC

Too focus on deallocation, but missed allocation.

* Benchmark

.code codes/string_test.go /START OMIT/,/END OMIT/

* Benchmark Result

   BenchmarkStringConcat-4    	   276979	   79043 ns/op   419450 B/op         1 allocs/op
   BenchmarkStringBuilder-4   	131586474	    10.6 ns/op       15 B/op         0 allocs/op

* Heap or Stack?

When possible, the Go compilers will allocate variables that are local to a function in that function's stack frame. However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.

In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.

.link https://golang.org/doc/faq#stack_or_heap

* Benchmark

.code codes/heapstack_test.go /START OMIT/,/END OMIT/

* Benchmark Result

   BenchmarkHeap-4   	  594841	      1852 ns/op	     800 B/op	     100 allocs/op
   BenchmarkStack-4   	29659628	        40.2 ns/op	       0 B/op	       0 allocs/op

* Bound Check

.code codes/bound_test.go /START OMIT/,/END OMIT/

* Bound Check

.code codes/bound_test.go /REMOVED OMIT/,/REMOVED_END OMIT/

* Benchmark Result

   BenchmarkBound-4           1000000000	0.335 ns/op	 0 B/op	0 allocs/op
   BenchmarkBoundRemoved-4    1000000000	0.332 ns/op	 0 B/op	0 allocs/op

Optimised automatically since 1.11

.link https://github.com/golang/go/issues/24876

Also

   go build -gcflags '-d=ssa/check_bce/debug=1' bound.go

* Sync Pool

.code codes/pool_test.go /NORMAL OMIT/,/NORMAL_END OMIT/

* Sync Pool

.code codes/pool_test.go /POOL OMIT/,/POOL_END OMIT/

* Benchmark Results

   BenchmarkNormal-4   	23216791	        51.7 ns/op	      64 B/op	       1 allocs/op
   BenchmarkPool-4   	37442522	        33.5 ns/op	       0 B/op	       0 allocs/op

* Compiler hints

* Escape analysis

.play codes/escape.go

   $ go build -gcflags '-m -m' escape.go                                                                                                                                                                                            [11:12:51]
   # command-line-arguments
   ./escape.go:5:6: cannot inline main: function too complex: cost 93 exceeds budget 80
   ./escape.go:11:13: inlining call to fmt.Println func(...interface {}) (int, error) { var fmt..autotmp_3 int; fmt..autotmp_3 = <N>; var fmt..autotmp_4 error; fmt..autotmp_4 = <N>; fmt..autotmp_3, fmt..autotmp_4 = fmt.Fprintln(io.Writer(os.Stdout), fmt.a...); return fmt..autotmp_3, fmt..autotmp_4 }
   ./escape.go:11:13: z escapes to heap
   ./escape.go:11:13: main []interface {} literal does not escape
   ./escape.go:11:13: io.Writer(os.Stdout) escapes to heap
   <autogenerated>:1: (*File).close .this does not escape

* We can also see the code generated

   go tool objdump escape

For more

   go tool compile --help

Also

   go build -gcflags '-S' escape.go

How code is being optimized

   GOSSAFUNC=main go tool compile escape.go

* Presentation

This presentation is powered by Go Present.
   go get golang.org/x/tools/cmd/present
   present

.link https://godoc.org/golang.org/x/tools/present

* Notable read

.link https://dubbelboer.com/talks/2019-05-20-go-performance-ams/#1
.link https://dave.cheney.net/2018/01/08/gos-hidden-pragmas
.link https://github.com/golang/go/wiki/CompilerOptimizations
.link https://rakyll.org/codegen/
